/*============================================================================== 
 * Copyright (c) 2012-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved. 
 * ==============================================================================*/
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Vuforia;
using System;

/// <summary>
/// UI Event Handler class that handles events generated by user-tap actions
/// over the UI Options Menu
/// </summary>
public class UDTUIEventHandler : ISampleAppUIEventHandler { 
        
    #region PUBLIC_MEMBER_PROPERTIES

    /// <summary>
    /// Currently, there is no mechanism to query the SDK to know whether or not extended tracking is enabled/disabled.
    /// Therefore, it needs to be handled at the app layer.
    /// </value>

    #endregion PUBLIC_MEMBER_PROPERTIES
    
    #region PUBLIC_METHODS 
    
    //SingleTap Gestures are captured by AppManager and calls this method for TapToFocus
    public override  void TriggerAutoFocus()
    {
        StartCoroutine(TriggerAutoFocusAndEnableContinuousFocusIfSet());
    }
    
    #endregion PUBLIC_METHODS
    
    #region PRIVATE_METHODS
    
    
    /// <summary>
    /// Activating trigger autofocus mode unsets continuous focus mode (if was previously enabled from the UI Options Menu)
    /// So, we wait for a second and turn continuous focus back on (if options menu shows as enabled)
    /// </returns>
    private IEnumerator TriggerAutoFocusAndEnableContinuousFocusIfSet()
    {
        //triggers a single autofocus operation 
        if (CameraDevice.Instance.SetFocusMode(CameraDevice.FocusMode.FOCUS_MODE_TRIGGERAUTO)) {
           
        }
        
        yield return new WaitForSeconds(1.0f);
        
        //continuous focus mode is turned back on 
        if (CameraDevice.Instance.SetFocusMode(CameraDevice.FocusMode.FOCUS_MODE_CONTINUOUSAUTO)) {
           
        }      
        
    }
    
    //We want autofocus to be enabled when the app starts
    private void EnableContinuousAutoFocus()
    {
        if (CameraDevice.Instance.SetFocusMode(CameraDevice.FocusMode.FOCUS_MODE_CONTINUOUSAUTO))
        {
           
        }
    }    

    private bool stopRunningObjectTracker()
    {
        bool needsObjectTrackerRestart = false;

        ObjectTracker objectTracker = TrackerManager.Instance.GetTracker<ObjectTracker>();
        if (objectTracker != null)
        {
            if (objectTracker.IsActive)
            {
                objectTracker.Stop();
                needsObjectTrackerRestart = true;
            }
        }
        return needsObjectTrackerRestart;
    }

    private bool restartRunningObjectTracker()
    {
        bool hasObjectTrackerRestarted = false;

        ObjectTracker objectTracker = TrackerManager.Instance.GetTracker<ObjectTracker>();
        if (objectTracker != null)
        {
            if (!objectTracker.IsActive)
            {
                hasObjectTrackerRestarted = objectTracker.Start();
            }
        }
        return hasObjectTrackerRestarted;
    }
    
    private void ResetCameraFacingToBack()
    {
        bool needsObjectTrackerRestart = stopRunningObjectTracker();

        CameraDevice.Instance.Stop();
        CameraDevice.Instance.Init(CameraDevice.CameraDirection.CAMERA_BACK);
        CameraDevice.Instance.Start();

        if (needsObjectTrackerRestart)
            restartRunningObjectTracker();
    }

    private bool ChangeCameraDirection(CameraDevice.CameraDirection direction)
    {
        bool directionSupported = false;

        bool needsObjectTrackerRestart = stopRunningObjectTracker();

        CameraDevice.Instance.Stop();
        CameraDevice.Instance.Deinit();
        if (CameraDevice.Instance.Init(direction))
        {
            directionSupported = true;
        }
        CameraDevice.Instance.Start();

        if (needsObjectTrackerRestart)
            restartRunningObjectTracker();

        return directionSupported;
    }
    
    #endregion PRIVATE_METHODS

}

